---
layout: post
title:  "单例模式详解"
categories: Spring中常用的设计模式
tags: Spring 设计模式
author: Zk1an
---

* content
{:toc}


## 单例模式应用场景
- 单例模式是指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点。
- 单例模式是创建型模式。
- 单例模式在现实生活中应用也非常广泛，例如，公司CEO、部门经理等。
J2EE标准的ServletContext、ServletContextConfig等、Spring框架应用中的ApplicationContext、数据库的连接池等也都是单例模式。
## 饿汉式单例模式
饿汉式单例模式在***类加载的时候就立即初始化，并且创建单例对象。*** 它绝对***线程安全*** ，在线程还没出现以前就初始化了，不可能存在访问安全问题。
- 优点：没有加任何锁，执行效率高，用户体验比懒汉式单例模式更好。
- 缺点：类加载的时候就初始化，不管用与不用都占着空间，浪费了内存，有可能"占着茅坑不拉屎"。

- Spring中IOC容器ApplicationContext本身就是典型的饿汉式单例模式。接下来看一段代码：
```java
public class HungarySingleton {
    //类加载的顺序要牢记：
    //先静态、后动态
    //先属性、后方法
    //先上后下
    private static final HungarySingleton hungarySingleton = new HungarySingleton();
    private HungarySingleton(){};
    public static HungarySingleton getInstance(){
        return hungarySingleton;
    }
}
```

- 还有另一种写法，利用静态代码块机制：
```java
public class HungaryStaticSingleton {
    private static final HungaryStaticSingleton hungarySingleton;
    private HungaryStaticSingleton(){};
    static {
        hungarySingleton= new HungaryStaticSingleton();
    }
    public static HungaryStaticSingleton getInstance(){
        return hungarySingleton;
    }
}
```
这两种写法都非常简单，也非常好理解，饿汉式单例模式适用于单例对象较少的情况，下面我们来看性能更优的写法。
## 懒汉式单例模式

懒汉式单例模式的特点是：被外部类调用的时候内部类才会加载。下面看懒汉式单例模式的简单实现LazySimpleSingleton：
```java
public class LazySimpleSingleton {
//懒汉式单例模式在外部需要使用的时候才进行实例化
    private LazySimpleSingleton(){}
    //静态块 公共内存区域
    private static LazySimpleSingleton lazy=null;
    public static LazySimpleSingleton getInstance(){
        if (lazy == null){
            lazy = new LazySimpleSingleton();
        }
        return lazy;
    }
}
```

然后写一个线程类ExecutorThread：
```java
public class ExecutorThread implements Runnable {
    @Override
    public void run() {
        LazySimpleSingleton singleton = LazySimpleSingleton.getInstance();
        System.out.println(Thread.currentThread().getName() + ":" + singleton);
    }
}
```

客户端测试代码如下：
```java
public class LazySimpleSingletonTest {
    public static void main(String[] args) {
        Thread t1 = new Thread(new ExecutorThread());
        Thread t2 = new Thread(new ExecutorThread());
        t1.start();
        t2.start();
        System.out.println("End");
    }
}
```

运行结果如下所示：
```java
End
Thread-0:com.mydemo.demo.designPrinciples.单例模式.LazySimpleSingleton@71053f05
Thread-1:com.mydemo.demo.designPrinciples.单例模式.LazySimpleSingleton@71053f05

Process finished with exit code 0
```

上面的代码有一定概率出现两种不同结果，这意味着上面的单例存在线程安全隐患。我们通过调试运行再看一下。这里教大家一种新技能，用线程模式调试，手动控制线程的执行顺序来跟踪内存的变化。
先给ExecutorThread类打上断点，如下图所示：
![2020091421548mfT0P](https://gitee.com/zhaokeyan/pic_repo/raw/master/uPic/%202020%2009%2014%2021%20548mfT0P.png)
使用鼠标单击断点，切换为Thread模式，如下图所示：
![202009142155SZnVAJ](https://gitee.com/zhaokeyan/pic_repo/raw/master/uPic/%202020%2009%2014%2021%2055SZnVAJ.png)
然后给LazySimpleSingleton类打上断点，同样标记为Thread模式，如下如所示：
![202009142157Q5N6nL](https://gitee.com/zhaokeyan/pic_repo/raw/master/uPic/%202020%2009%2014%2021%2057Q5N6nL.png)
切回客户端测试代码，同样打上断点，同时改为Thread模式，如下如所示：
![202009142159wTSYYH](https://gitee.com/zhaokeyan/pic_repo/raw/master/uPic/%202020%2009%2014%2021%2059wTSYYH.png)
开始"Debug"之后，会看到Debug控制台可以自由切换Thread的运行状态，如下图所示：
![202009142202tV8LHu](https://gitee.com/zhaokeyan/pic_repo/raw/master/uPic/%202020%2009%2014%2022%2002tV8LHu.png)
通过不断切换线程，并观测其内存状态，我们发现在线程环境下LazySimpleSingleton被实例了两次。有时我们得到的运行结果可能是相同的两个对象，实际上是被后面执行的线程覆盖了，我们看到了一个假象，
线程安全隐患依旧存在。那么，我们如何来优化代码，使得懒汉式单例模式在线程环境下安全呢？来看下面的代码，给getInstance()加上synchronized关键字，试这个方法变成线程同步方法：
```java
public class LazySimpleSingleton {
    private LazySimpleSingleton(){}
    //静态块 公共内存区域
    private static LazySimpleSingleton lazy=null;
    public synchronized static LazySimpleSingleton getInstance(){
        if (lazy == null){
            lazy = new LazySimpleSingleton();
        }
        return lazy;
    }
}
```
我们再来调试。当执行其中一个线程并调用getInstance()方法时，另一个线程再调用getInstance()方法，线程的状态由RUNNING变成了MONITOR，出现阻塞。直到第一个线程执行完，第二个线程才恢复到RUNNING状态
继续调用getInstance()方法，如下图所示：
![2020091422093WjKjz](https://gitee.com/zhaokeyan/pic_repo/raw/master/uPic/%202020%2009%2014%2022%20093WjKjz.png)
上图完美地展示了synchronized监视锁的运行状态，线程安全的问题解决了，但是，用synchronized加锁时，在线程数量比较多的情况下，如果CPU分配压力上升，则会导致大批线程阻塞，从而导致程序性能大幅下降。那么
有没有一种更好的方式，既能兼顾线程安全又能提升程序性能呢？答案是肯定的。我们来看双重检查锁的单例模式：
```java
public class LazyDoubleCheckSingleton {
    private LazyDoubleCheckSingleton(){};
    private static LazyDoubleCheckSingleton singleton;
    public static LazyDoubleCheckSingleton getInstance(){
        if (singleton == null){
            synchronized (LazyDoubleCheckSingleton.class){
                if (singleton==null){
                    singleton = new LazyDoubleCheckSingleton();
                    //1.分配内存给这个对象
                    //2.初始化对象
                    //3.设置singleton指向刚分配的内存地址
                }
            }
        }
        return singleton;
    }
}
```
现在，我们来进行断点调试，如下图所示：
![2020091422236DEpx7](https://gitee.com/zhaokeyan/pic_repo/raw/master/uPic/%202020%2009%2014%2022%20236DEpx7.png)
当第一个线程调用getInstance()方法时，第二个线程也可以调用。当第一个线程执行到synchronized时会上锁，第二个线程就会变成MONITOR状态，出现阻塞。此时，阻塞并不是基于整个LazyDoubleCheckSingleton
类的阻塞，而是在getInstance()方法内部的阻塞，只要逻辑不复杂，对于调用者而言感知不到。
## 小结



